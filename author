#!/usr/bin/python3
#
# author: Takes an APK as an input and constructs features for analysis
#

from bs4 import BeautifulSoup
from DexParser import DexParser
from message import *
import os
import settings
import subprocess


# Class for analyzing an APK file
class ApkAnalyzer:

    # TODO check if apk_file exists
    def __init__(self, apk_file):

        self.file = apk_file            # APK file path
        self.dir = apk_file + '.dec'    # extracted APK directory
        self.n_grams = []               # Creates an array to store n-grams
        self.dex = None                 # DexParser object

        verb('__init__', 'Created ApkAnalyzer for %s' % (apk_file))


    # Extract string data from res/values/strings.xml
    def get_xml_strings(self):

        strings_xml_path = os.path.join(self.dir, 'res/values/strings.xml')
        with open(strings_xml_path) as xml_file:
            parser = BeautifulSoup(xml_file, features='lxml-xml')

            # Pulls all <string> from strings.xml
            strings = parser.findAll("string")

            for phrase in strings:
                phrase = phrase.text.lower()
                
                tokens = [token for token in phrase.split(" ") if token != ""]

                # If the string is less than 3 words, it stores the whole string in the array
                if(len(tokens) < 3):
                    n_grams = zip(*[tokens[i:] for i in range(len(tokens))])
                    self.n_grams += n_grams
                    continue
                
                # This creates each 3-gram of a string if it has at least 3 words
                n_grams = zip(*[tokens[i:] for i in range(3)])
                self.n_grams += n_grams


    # Extract/decrypt APK file using `apktool`
    # TODO detect presence and build paths to important files, e.g. classes.dex
    def extract(self):

        # This is the command that extracts the APK file
        # Flags:
        #   d   This instructs apktool to decode an APK file
        #  -s   This prevents apktool from generating source code from classes.dex
        #  -o   This precedes the desired name of the output directory
        cmd = 'apktool d -s -o %s %s' % (self.dir, self.file)

        verb('extract', 'extracting %s to %s ...' % (self.file, self.dir))

        # Fork command
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE,
                stderr=subprocess.PIPE)

        # Wait for command completion
        proc.wait()

        # If the process exited with errors, print its output
        if proc.returncode != 0:
            error('extract', 'encountered errors for %s' % (self.file))
            error('extract', '\n%s' % (proc.stderr.read().decode()) )
        else:
            verb('extract', 'extraction completed successfuly')


    # Run entire analysis routine
    def run(self):

        self.extract()
        self.get_xml_strings()
        self.dex = DexParser(os.path.join(self.dir, 'classes.dex'))


if __name__ == '__main__':

    import sys

    # TODO parse verbosity through argv
    settings.VERBOSE = True

    if len(sys.argv) < 2:
        error(sys.argv[0], '%s <apkFileName>' % (sys.argv[0]), True, pre='usage')

    analyzer = ApkAnalyzer(sys.argv[1])
    analyzer.run()


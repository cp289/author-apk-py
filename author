#!/usr/bin/python3
#
# author: Takes an APK as an input and constructs features for analysis
#

from bs4 import BeautifulSoup
from DexParser import DexParser
from message import *
import os
import settings
import subprocess
from ngrams import *


# Class for analyzing an APK file
class ApkAnalyzer:

    # TODO check if apk_file exists
    def __init__(self, apk_file):

        self.file = apk_file            # APK file path
        self.dir = apk_file + '.dec'    # extracted APK directory

        self.n_grams = []               # Array to store n-grams
        self.n_static_fields = 0        # Number of static fields
        self.n_instance_fields = 0      # Number of static fields
        self.n_direct_methods = 0       # Number of direct methods
        self.n_virtual_methods = 0      # Number of virtual methods

        self.dex = None                 # DexParser object

        verb('__init__', 'Created ApkAnalyzer for %s' % (apk_file))


    # Extract/decrypt APK file using `apktool`
    # TODO detect presence and build paths to important files, e.g. classes.dex
    def extract(self):

        # This is the command that extracts the APK file
        # Flags:
        #   d   This instructs apktool to decode an APK file
        #  -s   This prevents apktool from generating source code from classes.dex
        #  -o   This precedes the desired name of the output directory
        cmd = 'apktool d -s -o %s %s' % (self.dir, self.file)

        verb('extract', 'extracting %s to %s ...' % (self.file, self.dir))

        # Fork command
        proc = subprocess.Popen(cmd.split(), stdout=subprocess.PIPE,
                stderr=subprocess.PIPE)

        # Wait for command completion
        proc.wait()

        # If the process exited with errors, print its output
        if proc.returncode != 0:
            error('extract', 'encountered errors for %s' % (self.file))
            error('extract', '\n%s' % (proc.stderr.read().decode()) )
        else:
            verb('extract', 'extraction completed successfuly')

    # Load and parse DEX file
    def loadDex(self):

        self.dex = DexParser(os.path.join(self.dir, 'classes.dex'))

    # Get number of direct/virtual methods, number of static/instance fields
    def getClassFeatures(self):

        for cls in self.dex.class_defs:
            if cls.class_data is not None:
                self.n_direct_methods += cls.class_data.direct_methods_size
                self.n_virtual_methods += cls.class_data.virtual_methods_size
                self.n_static_fields += cls.class_data.static_fields_size
                self.n_instance_fields += cls.class_data.instance_fields_size
        # TODO get interface data

    # Run entire analysis routine
    def run(self):

        self.extract()
        get_n_grams(self, 'res/values/strings.xml')
        self.loadDex()
        self.getMethodsFeatures()

    # Return feature vector
    def featureVector(self):

        return (
            self.n_direct_methods,
            self.n_virtual_methods,
            self.n_static_fields,
            self.n_instance_fields
        )


if __name__ == '__main__':

    import sys

    # TODO parse verbosity through argv

    settings.VERBOSE = True
    settings.NAME = sys.argv[0]

    if len(sys.argv) < 2:
        error(settings.NAME, '%s <apkFileName>' % (sys.argv[0]), True, pre='usage')

    analyzer = ApkAnalyzer(sys.argv[1])
    #analyzer.run()
    analyzer.loadDex()
    analyzer.getClassFeatures()
    verb(settings.NAME, analyzer.featureVector())

